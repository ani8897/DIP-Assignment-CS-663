Part 1

function [modified_pic] = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor)
	% Unsharp Masking %
	[h, w, num_chan] = size(original_pic);
	
	gauss_filter = fspecial('gaussian',filter_size,filter_sigma);
	unsharp_pic = imfilter(original_pic,gauss_filter);
	unsharp_mask_pic = original_pic - unsharp_pic;
	modified_pic = original_pic + scale_factor*unsharp_mask_pic;

end

%% MyMainScript

% Setting the color scale %
my_num_of_colors = 256;
col_scale =  [0:1/(my_num_of_colors-1):1]';
my_color_scale = [col_scale,col_scale,col_scale];

% Set to_save to 1, if you want to save the generated pictures %
to_save = 1;
% Loading the pictures %
moon_data = load('../data/superMoonCrop.mat');
lion_data = load('../data/lionCrop.mat');
moon_pic = moon_data.imageOrig;
lion_pic = lion_data.imageOrig;

tic;
%% Your code here

filter_sigma = 1;
filter_size = 9;
scale_factor = 5;
original_pic = lion_pic;
original_pic = imadjust(original_pic,stretchlim(original_pic),[0 1]);

modified_pic = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor);
modified_pic = imadjust(modified_pic,stretchlim(modified_pic),[0 1]);

savefig(my_color_scale,original_pic,modified_pic,'Sharpened','Part1_a.png',0,to_save);

filter_sigma = 3;
filter_size = 9;
scale_factor = 4;
original_pic = moon_pic;
original_pic = imadjust(original_pic,stretchlim(original_pic),[0 1]);

modified_pic = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor);
modified_pic = imadjust(modified_pic,stretchlim(modified_pic),[0 1]);

savefig(my_color_scale,original_pic,modified_pic,'Sharpened','Part1_b.png',0,to_save);

toc;

% Linear Contrast Stretching helper function %
function [modified_pic] = myLinearContrastStretching(original_pic)
	% Linear contrast stretching %
	[h, w, num_chan] = size(original_pic);
	modified_pic = zeros([h, w, num_chan]);
	% Running over all channels %
	for i=1:num_chan
		chan = original_pic(:,:,i);
		% Finding the max and min values %
		max_val = max(chan(:))
		min_val = min(chan(:))
		% Linearly stretching the values according to the formula in report %
		modified_pic(:,:,i) = double(chan-min_val)./double(max_val-min_val);
	end 
end

% Helper function to display and save processed images %
function savefig(my_color_scale,original_pic,modified_pic,title_name,file_name,is_color,to_save)
	if to_save==1
		fig = figure('units','normalized','outerposition',[0 0 1 1]); colormap(my_color_scale);
	else
		fig = figure; colormap(my_color_scale);
	end

	if is_color == 1
		colormap jet;
	else
		colormap(gray);
	end
	
	subplot(1,2,1), imagesc(original_pic), title('Original Image'), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,2,2), imagesc(modified_pic), title(title_name), colorbar, daspect([1 1 1]), axis tight;
	impixelinfo();
    
	if to_save == 1
		saveas(fig,file_name),close(fig);
	end
end



<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>myMainScript</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-08-20"><meta name="DC.source" content="myMainScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">MyMainScript</a></li><li><a href="#2">Your code here</a></li></ul></div><h2 id="1">MyMainScript</h2><pre class="codeinput"><span class="comment">% Setting the color scale %</span>
my_num_of_colors = 256;
col_scale =  [0:1/(my_num_of_colors-1):1]';
my_color_scale = [col_scale,col_scale,col_scale];

<span class="comment">% Set to_save to 1, if you want to save the generated pictures %</span>
to_save = 0;
<span class="comment">% Loading the pictures %</span>
moon_data = load(<span class="string">'../data/superMoonCrop.mat'</span>);
lion_data = load(<span class="string">'../data/lionCrop.mat'</span>);
moon_pic = moon_data.imageOrig;
lion_pic = lion_data.imageOrig;

tic;
</pre><h2 id="2">Your code here</h2><pre class="codeinput">filter_sigma = 1;
filter_size = 9;
scale_factor = 5;
original_pic = lion_pic;
original_pic = imadjust(original_pic,stretchlim(original_pic),[0 1]);

modified_pic = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor);
modified_pic = imadjust(modified_pic,stretchlim(modified_pic),[0 1]);

savefig(my_color_scale,original_pic,modified_pic,<span class="string">'Sharpened'</span>,<span class="string">'Part1_a.png'</span>,0,to_save);

filter_sigma = 3;
filter_size = 9;
scale_factor = 4;
original_pic = moon_pic;
original_pic = imadjust(original_pic,stretchlim(original_pic),[0 1]);

modified_pic = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor);
modified_pic = imadjust(modified_pic,stretchlim(modified_pic),[0 1]);

savefig(my_color_scale,original_pic,modified_pic,<span class="string">'Sharpened'</span>,<span class="string">'Part1_b.png'</span>,0,to_save);

toc;

<span class="comment">% Linear Contrast Stretching helper function %</span>
<span class="keyword">function</span> [modified_pic] = myLinearContrastStretching(original_pic)
	<span class="comment">% Linear contrast stretching %</span>
	[h, w, num_chan] = size(original_pic);
	modified_pic = zeros([h, w, num_chan]);
	<span class="comment">% Running over all channels %</span>
	<span class="keyword">for</span> i=1:num_chan
		chan = original_pic(:,:,i);
		<span class="comment">% Finding the max and min values %</span>
		max_val = max(chan(:))
		min_val = min(chan(:))
		<span class="comment">% Linearly stretching the values according to the formula in report %</span>
		modified_pic(:,:,i) = double(chan-min_val)./double(max_val-min_val);
	<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Helper function to display and save processed images %</span>
<span class="keyword">function</span> savefig(my_color_scale,original_pic,modified_pic,title_name,file_name,is_color,to_save)
	<span class="keyword">if</span> to_save==1
		fig = figure(<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>,[0 0 1 1]); colormap(my_color_scale);
	<span class="keyword">else</span>
		fig = figure; colormap(my_color_scale);
	<span class="keyword">end</span>

	<span class="keyword">if</span> is_color == 1
		colormap <span class="string">jet</span>;
	<span class="keyword">else</span>
		colormap(gray);
	<span class="keyword">end</span>

	subplot(1,2,1), imagesc(original_pic), title(<span class="string">'Original Image'</span>), colorbar, daspect([1 1 1]), axis <span class="string">tight</span>;
	subplot(1,2,2), imagesc(modified_pic), title(title_name), colorbar, daspect([1 1 1]), axis <span class="string">tight</span>;
	impixelinfo();

	<span class="keyword">if</span> to_save == 1
		saveas(fig,file_name),close(fig);
	<span class="keyword">end</span>
<span class="keyword">end</span>

<h1 id="6">Parameters Used</h1>
	<pre class="codeinput"><h3>For lionPic: </h3> Filter sigma : 1, filter_size = 9, scale_factor = 5.</pre>
	<pre class="codeinput"><h3>For moonPic: </h3> Filter sigma : 3, filter_size = 9, scale_factor = 4.</pre>

</pre><pre class="codeoutput">Elapsed time is 0.716870 seconds.
</pre><img vspace="5" hspace="5" src="myMainScript_01.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_02.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div>


<!--
##### SOURCE BEGIN #####
%% MyMainScript

% Setting the color scale %
my_num_of_colors = 256;
col_scale =  [0:1/(my_num_of_colors-1):1]';
my_color_scale = [col_scale,col_scale,col_scale];

% Set to_save to 1, if you want to save the generated pictures %
to_save = 0;
% Loading the pictures %
moon_data = load('../data/superMoonCrop.mat');
lion_data = load('../data/lionCrop.mat');
moon_pic = moon_data.imageOrig;
lion_pic = lion_data.imageOrig;

tic;
%% Your code here

filter_sigma = 1;
filter_size = 9;
scale_factor = 5;
original_pic = lion_pic;
original_pic = imadjust(original_pic,stretchlim(original_pic),[0 1]);

modified_pic = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor);
modified_pic = imadjust(modified_pic,stretchlim(modified_pic),[0 1]);

savefig(my_color_scale,original_pic,modified_pic,'Sharpened','Part1_a.png',0,to_save);

filter_sigma = 3;
filter_size = 9;
scale_factor = 4;
original_pic = moon_pic;
original_pic = imadjust(original_pic,stretchlim(original_pic),[0 1]);

modified_pic = myUnsharpMasking(original_pic,filter_size,filter_sigma,scale_factor);
modified_pic = imadjust(modified_pic,stretchlim(modified_pic),[0 1]);

savefig(my_color_scale,original_pic,modified_pic,'Sharpened','Part1_b.png',0,to_save);

toc;

% Linear Contrast Stretching helper function %
function [modified_pic] = myLinearContrastStretching(original_pic)
	% Linear contrast stretching %
	[h, w, num_chan] = size(original_pic);
	modified_pic = zeros([h, w, num_chan]);
	% Running over all channels %
	for i=1:num_chan
		chan = original_pic(:,:,i);
		% Finding the max and min values %
		max_val = max(chan(:))
		min_val = min(chan(:))
		% Linearly stretching the values according to the formula in report %
		modified_pic(:,:,i) = double(chan-min_val)./double(max_val-min_val);
	end 
end

% Helper function to display and save processed images %
function savefig(my_color_scale,original_pic,modified_pic,title_name,file_name,is_color,to_save)
	if to_save==1
		fig = figure('units','normalized','outerposition',[0 0 1 1]); colormap(my_color_scale);
	else
		fig = figure; colormap(my_color_scale);
	end

	if is_color == 1
		colormap jet;
	else
		colormap(gray);
	end
	
	subplot(1,2,1), imagesc(original_pic), title('Original Image'), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,2,2), imagesc(modified_pic), title(title_name), colorbar, daspect([1 1 1]), axis tight;
	impixelinfo();
    
	if to_save == 1
		saveas(fig,file_name),close(fig);
	end
end
##### SOURCE END #####

--></body></html>



--------------------------------------Part 2---------------------------------------------------------------------
function [modified_pic] = myBilateralFiltering(original_pic_old,spatial_sigma,intensity_sigma)
	% Bilateral Filtering %
	filter_size = double(idivide(int16(spatial_sigma*3),2,'floor')*2 +1);
	modified_pic = zeros(size(original_pic_old));
	[h_old, w_old, num_chan] = size(original_pic_old);
	original_pic = zeros(h_old+filter_size-1,w_old+filter_size-1);
	[h, w, num_chan] = size(original_pic);
	
	original_pic(int16((filter_size-1)/2)+1:h-int16((filter_size-1)/2),int16((filter_size-1)/2)+1:w-int16((filter_size-1)/2)) = original_pic_old;
	spatial_filter = fspecial('gaussian',filter_size,spatial_sigma);
	for i=1:h_old
		for j=1:w_old
			curr_intensity = original_pic_old(i,j);
			sub_area = original_pic(i:i+filter_size-1,j:j+filter_size-1);
			intensity_filter = gaussmf(sub_area,[intensity_sigma curr_intensity]);
			net_filter = spatial_filter.*intensity_filter;
			norm_const = sum(sum(net_filter));
			modified_pic(i,j) = sum(sum(net_filter.*sub_area))/norm_const;
		end
	end
end

%% MyMainScript

% Setting the color scale %
my_num_of_colors = 256;
col_scale =  [0:1/(my_num_of_colors-1):1]';
my_color_scale = [col_scale,col_scale,col_scale];

% Set to_save to 1, if you want to save the generated pictures %
to_save = 0;
% Loading the pictures %
barbara_data = load('../data/barbara.mat');
honey_pic = double(imread('../data/honeyCombReal.png'));
grass_pic = double(imread('../data/grass.png'));
barbara_pic = barbara_data.imageOrig;

% honey_pic = honey_data.imgCorrupt;
% grass_pic = grass_data.imgCorrupt;


%% Grass %%
% 0.1800 - factor

% 42.8400 - intenstity sigma

% 0.9000 - spatial sigma


%% Barbara %%
% 0.1000

% 10

% 1.4000


%% Honey %%
%  0.1600

% 40.6400

%  1.1000


tic;
%% Your code here

original_pic = barbara_pic;
seed = 5;
intensity_limit = [min(min(original_pic)),max(max(original_pic))];
intensity_range = intensity_limit(2) - intensity_limit(1);
noise_sigma = 0.05*intensity_range;
rng(seed);
gaussian_noise = randn(size(original_pic))*noise_sigma;
original_pic_corrupt = original_pic + gaussian_noise;
spatial_sigma =1.4;
intensity_sigma = intensity_range*0.1;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Bilaterally Filtered Image','Part2_a_1.png',0,to_save);
savefig(my_color_scale,original_pic,gaussian_noise,'Gaussian Noise Mask','Part2_a_1_mask.png',0,to_save);
disp('RMSD best')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.4*0.9;
intensity_sigma = intensity_range*0.1;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 0.9 spatial')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.4*1.1;
intensity_sigma = intensity_range*0.1;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 1.1 spatial')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.4;
intensity_sigma = intensity_range*0.1*0.9;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 0.9 intensity')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.4;
intensity_sigma = intensity_range*0.1*1.1;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 1.1 intensity')
disp(calculate_rmsd(modified_pic,original_pic))

original_pic = grass_pic;
seed = 5;
intensity_limit = [min(min(original_pic)),max(max(original_pic))];
intensity_range = intensity_limit(2) - intensity_limit(1);
noise_sigma = 0.05*intensity_range;
rng(seed);
gaussian_noise = randn(size(original_pic))*noise_sigma;
original_pic_corrupt = original_pic + gaussian_noise;
spatial_sigma =0.9;
intensity_sigma = intensity_range*0.18;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Bilaterally Filtered Image','Part2_a_2.png',0,to_save);
savefig(my_color_scale,original_pic,gaussian_noise,'Gaussian Noise Mask','Part2_a_2_mask.png',0,to_save);
disp('RMSD best')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =0.9*0.9;
intensity_sigma = intensity_range*0.18;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 0.9 spatial')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =0.9*1.1;
intensity_sigma = intensity_range*0.18;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 1.1 spatial')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =0.9;
intensity_sigma = intensity_range*0.18*0.9;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 0.9 intensity')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =0.9;
intensity_sigma = intensity_range*0.18*1.1;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 1.1 intensity')
disp(calculate_rmsd(modified_pic,original_pic))


original_pic = honey_pic;
seed = 5;
intensity_limit = [min(min(original_pic)),max(max(original_pic))];
intensity_range = intensity_limit(2) - intensity_limit(1);
noise_sigma = 0.05*intensity_range;
rng(seed);
gaussian_noise = randn(size(original_pic))*noise_sigma;
original_pic_corrupt = original_pic + gaussian_noise;
spatial_sigma =1.1;
intensity_sigma = intensity_range*0.16;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Bilaterally Filtered Image','Part2_a_3.png',0,to_save);
savefig(my_color_scale,original_pic,gaussian_noise,'Gaussian Noise Mask','Part2_a_3_mask.png',0,to_save);
disp('RMSD best')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.1*0.9;
intensity_sigma = intensity_range*0.16;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 0.9 spatial')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.1*1.1;
intensity_sigma = intensity_range*0.16;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 1.1 spatial')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.1;
intensity_sigma = intensity_range*0.16*0.9;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 0.9 intensity')
disp(calculate_rmsd(modified_pic,original_pic))
spatial_sigma =1.1;
intensity_sigma = intensity_range*0.16*1.1;
modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
disp('RMSD 1.1 intensity')
disp(calculate_rmsd(modified_pic,original_pic))


toc;

%% Barbara Pic %%
% RMSD best
%     3.2992

% RMSD 0.9 spatial
%     3.3031

% RMSD 1.1 spatial
%     3.3005

% RMSD 0.9 intensity
%     3.3269

% RMSD 1.1 intensity
%     3.3086


%% Grass Pic %%
% RMSD best
%     7.3624

% RMSD 0.9 spatial
%     7.3798

% RMSD 1.1 spatial
%     7.3770

% RMSD 0.9 intensity
%     7.3746

% RMSD 1.1 intensity
%     7.3849


%% Honey Pic %%
% RMSD best
%     7.3495

% RMSD 0.9 spatial
%     7.3716

% RMSD 1.1 spatial
%     7.5309

% RMSD 0.9 intensity
%     7.3782

% RMSD 1.1 intensity
%     7.3695



%% Tuning Code %%
% original_pic = grass_pic;

% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% noise_sigma = 0.05*intensity_range;
% rng(seed);
% gaussian_noise = randn(size(original_pic))*noise_sigma;
% original_pic_corrupt = original_pic + gaussian_noise;
% % spatial_sigma =3;
% best_spatial = 0;
% best_factor = 0;
% best_rmsd = 1.e100;

% f = waitbar(0, 'Starting Tuning');
% progress = 0.05;

% waitbar(progress,f,'Starting Grass');
% for spatial_sigma=0.8:0.05:1.1
% 	for intensity_sigma_factor=0.04:0.02:0.2
% 		intensity_sigma = intensity_range*intensity_sigma_factor;
% 		modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% 		rmsd_value = calculate_rmsd(original_pic,modified_pic);
% 		if rmsd_value < best_rmsd
% 			best_factor = intensity_sigma_factor;
% 			best_intensity = intensity_sigma;
% 			best_spatial = spatial_sigma;
% 			best_rmsd = rmsd_value;
% 		end
% 		progress = progress + 0.95/(81*3);
% 		waitbar(progress,f,'Computing...');
% 	end
% end

% waitbar(progress,f,'Done');
% disp(best_factor);
% disp(best_intensity);
% disp(best_spatial);

% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% spatial_sigma =best_spatial;
% intensity_sigma = intensity_range*best_factor;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Bilaterally Filtered Image','Part2_a_2.png',0,to_save);


% original_pic = barbara_pic;

% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% noise_sigma = 0.05*intensity_range;
% rng(seed);
% gaussian_noise = randn(size(original_pic))*noise_sigma;
% original_pic_corrupt = original_pic + gaussian_noise;
% % spatial_sigma =3;
% best_spatial = 0;
% best_factor = 0;
% best_rmsd = 1.e100;

% waitbar(progress,f,'Starting Barbara');
% for spatial_sigma=1:0.1:2
% 	for intensity_sigma_factor=0.04:0.02:0.2
% 		intensity_sigma = intensity_range*intensity_sigma_factor;
% 		modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% 		rmsd_value = calculate_rmsd(original_pic,modified_pic);
% 		if rmsd_value < best_rmsd
% 			best_factor = intensity_sigma_factor;
% 			best_intensity = intensity_sigma;
% 			best_spatial = spatial_sigma;
% 			best_rmsd = rmsd_value;
% 		end
% 		progress = progress + 0.95/(81*3);
% 		waitbar(progress,f,'Computing...');
% 	end
% end

% disp(best_factor);
% disp(best_intensity);
% disp(best_spatial);

% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% spatial_sigma =best_spatial;
% intensity_sigma = intensity_range*best_factor;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Bilaterally Filtered Image','Part2_a_2.png',0,to_save);


% original_pic = honey_pic;
% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% noise_sigma = 0.05*intensity_range;
% rng(seed);
% gaussian_noise = randn(size(original_pic))*noise_sigma;
% original_pic_corrupt = original_pic + gaussian_noise;
% best_spatial = 0;
% best_factor = 0;
% best_rmsd = 1.e100;

% waitbar(progress,f,'Starting honey');
% for spatial_sigma=0.8:0.05:1.1
% 	for intensity_sigma_factor=0.04:0.02:0.2
% 		intensity_sigma = intensity_range*intensity_sigma_factor;
% 		modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% 		rmsd_value = calculate_rmsd(original_pic,modified_pic);
% 		if rmsd_value < best_rmsd
% 			best_factor = intensity_sigma_factor;
% 			best_intensity = intensity_sigma;
% 			best_spatial = spatial_sigma;
% 			best_rmsd = rmsd_value;
% 		end
% 		progress = progress + 0.95/(81*3);
% 		waitbar(progress,f,'Computing...');
% 	end
% end

% waitbar(progress,f,'Done');
% disp(best_factor);
% disp(best_intensity);
% disp(best_spatial);

% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% spatial_sigma =best_spatial;
% intensity_sigma = intensity_range*best_factor;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Bilaterally Filtered Image','Part2_a_2.png',0,to_save);

%% End of tuning code %%

% RMSE Calculation Helper Function %
function [rmsd] = calculate_rmsd(pic1, pic2)
	rmsd = sqrt(sum(sum((pic1 - pic2).^2))/numel(pic1));
end

% Helper function to display and save 3 processed images %
function savefig3(my_color_scale,original_pic,mid_pic,modified_pic,mid_name,title_name,file_name,is_color,to_save)
	if to_save==1
		fig = figure('units','normalized','outerposition',[0 0 1 1]); colormap(my_color_scale);
	else
		fig = figure; colormap(my_color_scale);
	end

	if is_color == 1
		colormap jet;
	else
		colormap(gray);
	end
	
	subplot(1,3,1), imagesc(original_pic), title('Original Image'), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,3,2), imagesc(mid_pic), title(mid_name), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,3,3), imagesc(modified_pic), title(title_name), colorbar, daspect([1 1 1]), axis tight;
	impixelinfo();
    
	if to_save == 1
		saveas(fig,file_name),close(fig);
	end
end

% Helper function to display and save 2 processed images %
function savefig(my_color_scale,original_pic,modified_pic,title_name,file_name,is_color,to_save)
	if to_save==1
		fig = figure('units','normalized','outerposition',[0 0 1 1]); colormap(my_color_scale);
	else
		fig = figure; colormap(my_color_scale);
	end

	if is_color == 1
		colormap jet;
	end
	
	subplot(1,2,1), imagesc(original_pic), title('Original Image'), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,2,2), imagesc(modified_pic), title(title_name), colorbar, daspect([1 1 1]), axis tight;
	impixelinfo();

	if to_save == 1
		saveas(fig,file_name),close(fig);
	end
end


The optimal values for this pic are :
Intensity_sigma : 10
Spatial_sigma : 1.40
RMSD best
3.2992
RMSD 0.9 x optimal spatial
3.3031
RMSD 1.1 x optimal spatial
3.3005
RMSD 0.9 x optimal intensity
3.3269
RMSD 1.1 x optimal intensity
3.3086
The spatial gaussian mask used :2) Grass Pic ​ :
The gaussian noise added was :The optimal parameters :
42.8400 - intensity sigma
0.9000 - spatial sigma
%% Grass Pic %%
RMSD best
7.3624
RMSD 0.9 * spatial
7.3798
RMSD 1.1* spatial
7.3770
RMSD 0.9 *intensity
7.3746
RMSD 1.1 *intensity
7.3849
The spatial gaussian mask used :3) Honey Comb Pic :
The gaussian noise added was :Intensity-sigma : 40.6400
Spatial_sigma: 1.1000
% Honey Pic %%
RMSD best
7.3495
RMSD 0.9 spatial
7.3716
RMSD 1.1 spatial
7.5309
RMSD 0.9 intensity
7.3782
RMSD 1.1 intensity
7.3695
The gaussian mask for spatial used was :


-------------------------------------------------Part 3----------------------------------------------------------------------------
function [modified_pic] = myPatchBasedFiltering(original_pic_old,h_sigma)
	% Patch Based Filtering %
	f = waitbar(0, 'Starting Patch Based Filtering');
	
	window_size = 25;
	patch_size = 9;
	patch_gaussian_sigma = 2;

	modified_pic = zeros(size(original_pic_old));
	[h_old, w_old, num_chan] = size(original_pic_old);
	original_pic = zeros(h_old+window_size+patch_size-2,w_old+window_size+patch_size-2);
	[h, w, num_chan] = size(original_pic);
	padding_size = int16((window_size+patch_size)/2); 
	original_pic(padding_size:h-padding_size+1,padding_size:w-padding_size+1) = original_pic_old;	
	patch_gaussian_filter = fspecial('gaussian',patch_size,patch_gaussian_sigma);
	% imshow(patch_gaussian_filter);

	progress = 0.02;	
	for i=1:h_old
		for j=1:w_old
			curr_intensity = original_pic_old(i,j);
			patch_pad = (patch_size-1)/2;
			displace_less = padding_size-patch_pad;
			displace_more = padding_size+patch_pad;
			curr_patch = original_pic(i+displace_less:i+displace_more,j+displace_less:j+displace_more);
			filter_weights = zeros(window_size);
			h_wind = 1;
			w_wind = 1;
			for k=i+patch_pad:i+patch_pad+window_size-1
				for l=j+patch_pad:j+patch_pad+window_size-1
					temp_patch = original_pic(k-patch_pad:k+patch_pad,l-patch_pad:l+patch_pad);
					filter_weights(h_wind,w_wind) = patch_weights(temp_patch,curr_patch,patch_gaussian_filter,h_sigma);
					w_wind = w_wind + 1;
				end
				w_wind = 1;
				h_wind = h_wind + 1;
			end
			sub_area = original_pic(i+patch_pad:i+patch_pad+window_size-1,j+patch_pad:j+patch_pad+window_size-1);
			norm_const = sum(sum(filter_weights));
			modified_pic(i,j) = sum(sum(filter_weights.*sub_area))/norm_const;


			progress = progress + (0.97/double(h_old*w_old));
			waitbar(progress,f,'Computing...');
		end
	end
	waitbar(1,f,'Done');
	close(f);
end

function [patch_weight] = patch_weights(patch1, patch2, patch_gaussian_filter, h_sigma)
	patch1 = patch1.*patch_gaussian_filter;
	patch2 = patch2.*patch_gaussian_filter;
	patch_weight = exp(-sum(sum((patch1-patch2).^2))/(h_sigma^2));
end

%% MyMainScript

% Setting the color scale %
my_num_of_colors = 256;
col_scale =  [0:1/(my_num_of_colors-1):1]';
my_color_scale = [col_scale,col_scale,col_scale];

% Set to_save to 1, if you want to save the generated pictures %
to_save = 1;
% Loading the pictures %
barbara_data = load('../data/barbara.mat');
honey_pic = double(imread('../data/honeyCombReal.png'));
grass_pic = double(imread('../data/grass.png'));

barbara_pic = barbara_data.imageOrig;
% honey_pic = honey_data.imgCorrupt;
% grass_pic = grass_data.imgCorrupt;


%% Intial Tuning %%
tic;
% %% Your code here
% %% Displaying the patch based filtering gaussian mask applied to the patches:
% patch_size = 9;
% patch_gaussian_sigma = 2;
% patch_gaussian_filter = fspecial('gaussian',patch_size,patch_gaussian_sigma);
% savefig3(my_color_scale,patch_gaussian_filter,patch_gaussian_filter,patch_gaussian_filter,'Gaussian Noise','Gaussian Noise',strcat(strcat('Part3_a_mask',num2str(12)),'.png'),0,to_save);

% imshow(patch_gaussian_filter);

%% Grass Pic
% RMSD best
%    25.3322

% RMSD 0.9
%    25.4009

% RMSD 1.1
%    25.3635
%%
intensity_scale = 0.016
original_pic = grass_pic;
seed = 5;
intensity_limit = [min(min(original_pic)),max(max(original_pic))];
intensity_range = intensity_limit(2) - intensity_limit(1);
noise_sigma = 0.05*intensity_range;
rng(seed);
gaussian_noise = randn(size(original_pic))*noise_sigma;
original_pic_corrupt = original_pic + gaussian_noise;
h_sigma = intensity_range*intensity_scale;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_2_',num2str(intensity_scale)),'.png'),0,to_save);

disp('RMSD best')
disp(calculate_rmsd(modified_pic,original_pic))
h_sigma = intensity_range*intensity_scale*0.9;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
disp('RMSD 0.9')
disp(calculate_rmsd(modified_pic,original_pic))
h_sigma = intensity_range*intensity_scale*1.1;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
disp('RMSD 1.1')
disp(calculate_rmsd(modified_pic,original_pic))

%% Barbara Pic
% RMSD best
%    25.3322

% RMSD 0.9
%    25.4009

% RMSD 1.1
%    25.3635
%%
intensity_scale = 0.015
original_pic = barbara_pic;
seed = 5;
intensity_limit = [min(min(original_pic)),max(max(original_pic))];
intensity_range = intensity_limit(2) - intensity_limit(1);
noise_sigma = 0.05*intensity_range;
rng(seed);
gaussian_noise = randn(size(original_pic))*noise_sigma;
original_pic_corrupt = original_pic + gaussian_noise;
h_sigma = intensity_range*intensity_scale;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_1_',num2str(intensity_scale)),'.png'),0,to_save);

disp('RMSD best')
disp(calculate_rmsd(modified_pic,original_pic))
h_sigma = intensity_range*intensity_scale*0.9;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
disp('RMSD 0.9')
disp(calculate_rmsd(modified_pic,original_pic))
h_sigma = intensity_range*intensity_scale*1.1;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
disp('RMSD 1.1')
disp(calculate_rmsd(modified_pic,original_pic))


%% Honey Pic
% RMSD best
%    25.3322

% RMSD 0.9
%    25.4009

% RMSD 1.1
%    25.3635
%%

intensity_scale = 0.018
original_pic = honey_pic;
seed = 5;
intensity_limit = [min(min(original_pic)),max(max(original_pic))];
intensity_range = intensity_limit(2) - intensity_limit(1);
noise_sigma = 0.05*intensity_range;
rng(seed);
gaussian_noise = randn(size(original_pic))*noise_sigma;
original_pic_corrupt = original_pic + gaussian_noise;
h_sigma = intensity_range*intensity_scale;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_3_',num2str(intensity_scale)),'.png'),0,to_save);

disp('RMSD best')
disp(calculate_rmsd(modified_pic,original_pic))
h_sigma = intensity_range*intensity_scale*0.9;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
disp('RMSD 0.9')
disp(calculate_rmsd(modified_pic,original_pic))
h_sigma = intensity_range*intensity_scale*1.1;
modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
disp('RMSD 1.1')
disp(calculate_rmsd(modified_pic,original_pic))
% end
toc;

% RMSE Calculation Helper Function %
function [rmsd] = calculate_rmsd(pic1, pic2)
	rmsd = sqrt(sum(sum((pic1 - pic2).^2))/numel(pic1));
end

% Helper function to display and save processed images %
function savefig3(my_color_scale,original_pic,mid_pic,modified_pic,mid_name,title_name,file_name,is_color,to_save)
	if to_save==1
		fig = figure('units','normalized','outerposition',[0 0 1 1]); colormap(my_color_scale);
	else
		fig = figure; colormap(my_color_scale);
	end

	if is_color == 1
		colormap jet;
	else
		colormap(gray);
	end
	
	subplot(1,3,1), imagesc(original_pic), title('Original Image'), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,3,2), imagesc(mid_pic), title(mid_name), colorbar, daspect([1 1 1]), axis tight;
	subplot(1,3,3), imagesc(modified_pic), title(title_name), colorbar, daspect([1 1 1]), axis tight;
	impixelinfo();
    
	if to_save == 1
		saveas(fig,file_name),close(fig);
	end
end

% % for intensity_scale = [0.005,0.01,0.02,0.05,0.1]

% 	original_pic = grass_pic;
% 	seed = 5;
% 	intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% 	intensity_range = intensity_limit(2) - intensity_limit(1);
% 	noise_sigma = 0.01*intensity_range;
% 	rng(seed);
% 	gaussian_noise = randn(size(original_pic))*noise_sigma;
% 	original_pic_corrupt = original_pic + gaussian_noise;
% 	h_sigma = intensity_range*intensity_scale;
% 	modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% 	savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_2_',num2str(intensity_scale)),'.png'),0,to_save);

% 	original_pic = barbara_pic;
% 	seed = 5;
% 	intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% 	intensity_range = intensity_limit(2) - intensity_limit(1);
% 	noise_sigma = 0.01*intensity_range;
% 	rng(seed);
% 	gaussian_noise = randn(size(original_pic))*noise_sigma;
% 	original_pic_corrupt = original_pic + gaussian_noise;
% 	h_sigma = intensity_range*intensity_scale;
% 	modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% 	savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_1_',num2str(intensity_scale)),'.png'),0,to_save);

% 	original_pic = honey_pic;
% 	seed = 5;
% 	intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% 	intensity_range = intensity_limit(2) - intensity_limit(1);
% 	noise_sigma = 0.01*intensity_range;
% 	rng(seed);
% 	gaussian_noise = randn(size(original_pic))*noise_sigma;
% 	original_pic_corrupt = original_pic + gaussian_noise;
% 	h_sigma = intensity_range*intensity_scale;
% 	modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% 	savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_3_',num2str(intensity_scale)),'.png'),0,to_save);

% 	disp('Done')
% 	disp(intensity_scale)
% % end
% toc;
% disp('RMSD best')
% disp(calculate_rmsd(modified_pic,original_pic))
% spatial_sigma =1.4*0.9;
% intensity_sigma = intensity_range*0.1;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% disp('RMSD 0.9 spatial')
% disp(calculate_rmsd(modified_pic,original_pic))
% spatial_sigma =1.4*1.1;
% intensity_sigma = intensity_range*0.1;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% disp('RMSD 1.1 spatial')
% disp(calculate_rmsd(modified_pic,original_pic))
% spatial_sigma =1.4;
% intensity_sigma = intensity_range*0.1*0.9;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% disp('RMSD 0.9 intensity')
% disp(calculate_rmsd(modified_pic,original_pic))
% spatial_sigma =1.4;
% intensity_sigma = intensity_range*0.1*1.1;
% modified_pic = myBilateralFiltering(original_pic_corrupt, spatial_sigma, intensity_sigma);
% disp('RMSD 1.1 intensity')
% disp(calculate_rmsd(modified_pic,original_pic))

% f = waitbar(0, 'Starting Tuning');
% progress = 0.05;

% waitbar(progress,f,'Starting Grass');

% original_pic = grass_pic;
% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);

% noise_sigma = 0.05*intensity_range;

% rng(seed);
% gaussian_noise = randn(size(original_pic))*noise_sigma;
% original_pic_corrupt = original_pic + gaussian_noise;

% best_intensity_scale = 0;
% best_rmsd = 1.e100;

% %% Your code here
% for intensity_scale = 0.011:0.001:0.019
% 	h_sigma = intensity_range*intensity_scale;
% 	modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% 	rmsd_value = calculate_rmsd(original_pic,modified_pic);
% 	if rmsd_value < best_rmsd
% 		best_intensity_scale = intensity_scale;
% 		best_rmsd = rmsd_value;
% 	end
% 	progress = progress + 0.28/(5);
% 	waitbar(progress,f,'Tuning...');
% end

% % waitbar(progress,f,'Done');
% disp("best_rmsd")
% disp(best_rmsd)
% disp("best_intensity_scale")
% disp(best_intensity_scale);

% h_sigma = intensity_range*best_intensity_scale;
% modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% rmsd_value = calculate_rmsd(original_pic,modified_pic);
% savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_2_',num2str(intensity_scale)),'.png'),0,to_save);


% %%--------------------------------Barbara Tuning-----------------------------------------
% waitbar(progress,f,'Starting Barbara');

% original_pic = barbara_pic;
% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);
% noise_sigma = 0.05*intensity_range;
% rng(seed);
% gaussian_noise = randn(size(original_pic))*noise_sigma;
% original_pic_corrupt = original_pic + gaussian_noise;

% best_intensity_scale = 0;
% best_rmsd = 1.e100;

% for intensity_scale = 0.008:0.01:0.018	
% 	h_sigma = intensity_range*intensity_scale;
% 	modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% 	rmsd_value = calculate_rmsd(original_pic,modified_pic);
% 	if rmsd_value < best_rmsd
% 		best_intensity_scale = intensity_scale;
% 		best_rmsd = rmsd_value;
% 	end
% 	progress = progress + 0.33/3;
% 	waitbar(progress,f,'Tuning...');
% end

% % waitbar(progress,f,'Done');

% disp("best_rmsd")
% disp(best_rmsd)
% disp("best_intensity_scale")
% disp(best_intensity_scale);

% h_sigma = intensity_range*best_intensity_scale;
% modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% rmsd_value = calculate_rmsd(original_pic,modified_pic);
% savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_1_',num2str(intensity_scale)),'.png'),0,to_save);

%%--------------------------------Honey Tuning-----------------------------------------

% waitbar(progress,f,'Starting Honey');

% original_pic = honey_pic;
% seed = 5;
% intensity_limit = [min(min(original_pic)),max(max(original_pic))];
% intensity_range = intensity_limit(2) - intensity_limit(1);
% noise_sigma = 0.05*intensity_range;
% rng(seed);
% gaussian_noise = randn(size(original_pic))*noise_sigma;
% original_pic_corrupt = original_pic + gaussian_noise;
% savefig3(my_color_scale,original_pic,original_pic_corrupt,original_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_2_',num2str(intensity_scale)),'.png'),0,to_save);

% best_intensity_scale = 0;
% best_rmsd = 1.e100;

% for intensity_scale = 0.018:0.001:0.020	
% 	h_sigma = intensity_range*intensity_scale;
% 	modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% 	rmsd_value = calculate_rmsd(original_pic,modified_pic);
% 	if rmsd_value < best_rmsd
% 		best_intensity_scale = intensity_scale;
% 		best_rmsd = rmsd_value;
% 	end
% 	progress = progress + 0.33;
% 	waitbar(progress,f,'Tuning...');
% end

% disp("best_rmsd")
% disp(best_rmsd)
% disp("best_intensity_scale")
% disp(best_intensity_scale);

% h_sigma = intensity_range*best_intensity_scale;
% modified_pic = myPatchBasedFiltering(original_pic_corrupt, h_sigma);
% rmsd_value = calculate_rmsd(original_pic,modified_pic);
% savefig3(my_color_scale,original_pic,original_pic_corrupt,modified_pic,'Corrupted Image','Patch Filtered Image',strcat(strcat('Part3_a_2_',num2str(intensity_scale)),'.png'),0,to_save);

% waitbar(progress,f,'Done');
% close(f)

RMSD best sigma - 25.3322
RMSD 0.9 sigma - 25.4009
RMSD 1.1 sigma - 25.3635


This was the Barbara pic with optimal h = 0.015
RMSD best sigma = 10.4966
RMSD 0.9 sigma = 10.6587
RMSD 1.1 sigma = 10.3486
Due to last minute changes in the input images, we couldn’t tune this properly,
this was the best according to the tuned so far.This was the honeycomb pic with optimal parameter values: h=0.018
RMSD best sigma - 23.8869
RMSD 0.9 sigma - 23.9866
RMSD 1.1 sigma - 23.9216Gaussian Filter used to make patches isotropic
